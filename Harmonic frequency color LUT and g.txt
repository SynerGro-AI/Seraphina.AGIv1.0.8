/** Harmonic frequency color LUT and gradient utilities (runtime palette override capable) */
let harmonicBase: Record<number,string> = {
  417:'#D8BFD8', 528:'#FF69B4', 639:'#ADD8E6', 852:'#8A2BE2', 963:'#FF4D6D'
};
let orderedHarmonics = Object.keys(harmonicBase).map(Number).sort((a,b)=>a-b);

// Attempt lazy palette override from JSON (client-side only)
let paletteLoaded = false;
export async function loadHarmonicPaletteOnce(){
  if (paletteLoaded) return harmonicBase;
  paletteLoaded = true;
  try {
    const res = await fetch('/palette.json', { cache:'no-store' });
    if (res.ok){
      const json = await res.json();
      if (json?.harmonics){
        harmonicBase = { ...harmonicBase, ...Object.fromEntries(Object.entries(json.harmonics).map(([k,v])=>[Number(k), String(v)])) };
        orderedHarmonics = Object.keys(harmonicBase).map(Number).sort((a,b)=>a-b);
      }
    }
  } catch(_e){ /* ignore */ }
  return harmonicBase;
}
export function getHarmonicBase(){ return harmonicBase; }

function hexToRgb(h:string){ const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h)!; return { r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16) }; }
function rgbToHex({r,g,b}:{r:number;g:number;b:number}){ const to = (v:number)=>('0'+v.toString(16)).slice(-2); return `#${to(r)}${to(g)}${to(b)}`; }
function lerp(a:number,b:number,t:number){ return a+(b-a)*t; }

export function frequencyToColor(f:number){
  if (harmonicBase[f]) return harmonicBase[f];
  // interpolate between nearest harmonics
  let lower = orderedHarmonics[0]; let upper = orderedHarmonics[orderedHarmonics.length-1];
  for (let i=0;i<orderedHarmonics.length-1;i++){ const a=orderedHarmonics[i], b=orderedHarmonics[i+1]; if (f>=a && f<=b){ lower=a; upper=b; break; } }
  const t = (f-lower)/(upper-lower);
  const c1 = hexToRgb(harmonicBase[lower]); const c2 = hexToRgb(harmonicBase[upper]);
  return rgbToHex({ r:Math.round(lerp(c1.r,c2.r,t)), g:Math.round(lerp(c1.g,c2.g,t)), b:Math.round(lerp(c1.b,c2.b,t)) });
}

export function valueToHarmonic(value:number){
  // Map arbitrary metric value to harmonic range (417..963)
  const minH = orderedHarmonics[0]; const maxH = orderedHarmonics[orderedHarmonics.length-1];
  const norm = Math.min(1, Math.max(0, Math.log10(1+Math.abs(value))/3));
  const freq = minH + (maxH-minH)*norm;
  // Snap close to base if within small delta
  for (const h of orderedHarmonics){ if (Math.abs(h-freq) < 8) return h; }
  return Math.round(freq);
}

export function valueToColor(value:number){ return frequencyToColor(valueToHarmonic(value)); }
