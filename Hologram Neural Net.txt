<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holographic Neural Net</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        /* Hologram effect styles */
        .hologram {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            filter: brightness(1.5) contrast(1.2);
            opacity: 0.8;
            animation: flicker 2s infinite alternate;
        }
        @keyframes flicker {
            0% { opacity: 0.7; }
            100% { opacity: 0.9; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="container"></div>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        // Central node
        const centerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const centerMaterial = new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const center = new THREE.Mesh(centerGeometry, centerMaterial);
        scene.add(center);

        // Function to create branching lines like neural connections or plasma discharges
        function createBranch(startPos, direction, length, depth, maxDepth) {
            if (depth > maxDepth) return;

            const endPos = startPos.clone().add(direction.clone().multiplyScalar(length));

            // Create line for this segment
            const points = [startPos, endPos];
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: Math.random() > 0.5 ? 0x00ffff : 0xff00ff, // Blue or purple hues
                transparent: true,
                opacity: 0.6 - (depth * 0.1),
                blending: THREE.AdditiveBlending
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);

            // Add small node at end
            const nodeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const nodeMaterial = new THREE.MeshBasicMaterial({
                color: lineMaterial.color,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
            node.position.copy(endPos);
            scene.add(node);

            // Branch out recursively
            if (depth < maxDepth) {
                const branchCount = Math.floor(Math.random() * 3) + 2; // 2-4 branches
                for (let i = 0; i < branchCount; i++) {
                    const newDir = direction.clone().applyAxisAngle(new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize(), Math.PI / (4 + Math.random() * 4));
                    createBranch(endPos, newDir.normalize(), length * (0.6 + Math.random() * 0.4), depth + 1, maxDepth);
                }
            }
        }

        // Generate multiple root branches from center
        const rootBranchCount = 20; // Number of main branches
        const maxDepth = 4; // Branching depth
        for (let i = 0; i < rootBranchCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const direction = new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta),
                Math.sin(phi) * Math.sin(theta),
                Math.cos(phi)
            );
            createBranch(new THREE.Vector3(0, 0, 0), direction, 2 + Math.random() * 3, 1, maxDepth);
        }

        // Camera position
        camera.position.z = 15;

        // Animation loop with rotation and subtle pulsing
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            scene.rotation.y += 0.002; // Slow rotation
            // Subtle scale pulse for hologram effect
            const pulse = 1 + Math.sin(time) * 0.05;
            center.scale.set(pulse, pulse, pulse);
            renderer.render(scene, camera);
        }
        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>